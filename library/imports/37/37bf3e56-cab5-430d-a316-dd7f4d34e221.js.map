{"version":3,"sources":["../../../../../../../../assets/script/wx/utils/cryptojs/lib/assets/script/wx/utils/cryptojs/lib/BlockModes.js"],"names":["C","window","require","Crypto","C_pad","pad","_requiredPadding","cipher","message","blockSizeInBytes","_blocksize","reqd","length","_unpadLength","pop","i","NoPadding","unpad","ZeroPadding","push","iso7816","ansix923","iso10126","Math","floor","random","pkcs7","C_mode","mode","Mode","padding","_padding","prototype","encrypt","m","iv","_doEncrypt","decrypt","_doDecrypt","ECB","apply","arguments","ECB_prototype","offset","_encryptblock","c","_decryptblock","fixOptions","options","CBC","CBC_prototype","prevCryptedBlock","thisCryptedBlock","slice","CFB","CFB_prototype","keystream","j","b","OFB","OFB_prototype","CTR","CTR_prototype","counter"],"mappings":"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","file":"BlockModes.js","sourceRoot":"../../../../../../../../assets/script/wx/utils/cryptojs/lib","sourcesContent":["/*!\r\n * Crypto-JS contribution from Simon Greatrix\r\n */\r\n\r\n(function(){\r\n\r\nvar C = (typeof window === 'undefined') ? require('./Crypto').Crypto : window.Crypto;\r\n\r\n// Create pad namespace\r\nvar C_pad = C.pad = {};\r\n\r\n// Calculate the number of padding bytes required.\r\nfunction _requiredPadding(cipher, message) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    var reqd = blockSizeInBytes - message.length % blockSizeInBytes;\r\n    return reqd;\r\n};\r\n\r\n// Remove padding when the final byte gives the number of padding bytes.\r\nvar _unpadLength = function (message) {\r\n        var pad = message.pop();\r\n        for (var i = 1; i < pad; i++) {\r\n            message.pop();\r\n        }\r\n    };\r\n\r\n// No-operation padding, used for stream ciphers\r\nC_pad.NoPadding = {\r\n        pad : function (cipher,message) {},\r\n        unpad : function (message) {}\r\n    };\r\n\r\n// Zero Padding.\r\n//\r\n// If the message is not an exact number of blocks, the final block is\r\n// completed with 0x00 bytes. There is no unpadding.\r\nC_pad.ZeroPadding = {\r\n    pad : function (cipher, message) {\r\n        var blockSizeInBytes = cipher._blocksize * 4;\r\n        var reqd = message.length % blockSizeInBytes;\r\n        if( reqd!=0 ) {\r\n            for(reqd = blockSizeInBytes - reqd; reqd>0; reqd--) {\r\n                message.push(0x00);\r\n            }\r\n        }\r\n    },\r\n\r\n    unpad : function (message) {}\r\n};\r\n\r\n// ISO/IEC 7816-4 padding.\r\n//\r\n// Pads the plain text with an 0x80 byte followed by as many 0x00\r\n// bytes are required to complete the block.\r\nC_pad.iso7816 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        message.push(0x80);\r\n        for (; reqd > 1; reqd--) {\r\n            message.push(0x00);\r\n        }\r\n    },\r\n\r\n    unpad : function (message) {\r\n        while (message.pop() != 0x80) {}\r\n    }\r\n};\r\n\r\n// ANSI X.923 padding\r\n//\r\n// The final block is padded with zeros except for the last byte of the\r\n// last block which contains the number of padding bytes.\r\nC_pad.ansix923 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 1; i < reqd; i++) {\r\n            message.push(0x00);\r\n        }\r\n        message.push(reqd);\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// ISO 10126\r\n//\r\n// The final block is padded with random bytes except for the last\r\n// byte of the last block which contains the number of padding bytes.\r\nC_pad.iso10126 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 1; i < reqd; i++) {\r\n            message.push(Math.floor(Math.random() * 256));\r\n        }\r\n        message.push(reqd);\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// PKCS7 padding\r\n//\r\n// PKCS7 is described in RFC 5652. Padding is in whole bytes. The\r\n// value of each added byte is the number of bytes that are added,\r\n// i.e. N bytes, each of value N are added.\r\nC_pad.pkcs7 = {\r\n    pad : function (cipher, message) {\r\n        var reqd = _requiredPadding(cipher, message);\r\n        for (var i = 0; i < reqd; i++) {\r\n            message.push(reqd);\r\n        }\r\n    },\r\n\r\n    unpad : _unpadLength\r\n};\r\n\r\n// Create mode namespace\r\nvar C_mode = C.mode = {};\r\n\r\n/**\r\n * Mode base \"class\".\r\n */\r\nvar Mode = C_mode.Mode = function (padding) {\r\n    if (padding) {\r\n        this._padding = padding;\r\n    }\r\n};\r\n\r\nMode.prototype = {\r\n    encrypt: function (cipher, m, iv) {\r\n        this._padding.pad(cipher, m);\r\n        this._doEncrypt(cipher, m, iv);\r\n    },\r\n\r\n    decrypt: function (cipher, m, iv) {\r\n        this._doDecrypt(cipher, m, iv);\r\n        this._padding.unpad(m);\r\n    },\r\n\r\n    // Default padding\r\n    _padding: C_pad.iso7816\r\n};\r\n\r\n\r\n/**\r\n * Electronic Code Book mode.\r\n * \r\n * ECB applies the cipher directly against each block of the input.\r\n * \r\n * ECB does not require an initialization vector.\r\n */\r\nvar ECB = C_mode.ECB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar ECB_prototype = ECB.prototype = new Mode;\r\n\r\n// Concrete steps for Mode template\r\nECB_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    // Encrypt each block\r\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\r\n        cipher._encryptblock(m, offset);\r\n    }\r\n};\r\nECB_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    // Decrypt each block\r\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\r\n        cipher._decryptblock(c, offset);\r\n    }\r\n};\r\n\r\n// ECB never uses an IV\r\nECB_prototype.fixOptions = function (options) {\r\n    options.iv = [];\r\n};\r\n\r\n\r\n/**\r\n * Cipher block chaining\r\n * \r\n * The first block is XORed with the IV. Subsequent blocks are XOR with the\r\n * previous cipher output.\r\n */\r\nvar CBC = C_mode.CBC = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CBC_prototype = CBC.prototype = new Mode;\r\n\r\n// Concrete steps for Mode template\r\nCBC_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n\r\n    // Encrypt each block\r\n    for (var offset = 0; offset < m.length; offset += blockSizeInBytes) {\r\n        if (offset == 0) {\r\n            // XOR first block using IV\r\n            for (var i = 0; i < blockSizeInBytes; i++)\r\n            m[i] ^= iv[i];\r\n        } else {\r\n            // XOR this block using previous crypted block\r\n            for (var i = 0; i < blockSizeInBytes; i++)\r\n            m[offset + i] ^= m[offset + i - blockSizeInBytes];\r\n        }\r\n        // Encrypt block\r\n        cipher._encryptblock(m, offset);\r\n    }\r\n};\r\nCBC_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n\r\n    // At the start, the previously crypted block is the IV\r\n    var prevCryptedBlock = iv;\r\n\r\n    // Decrypt each block\r\n    for (var offset = 0; offset < c.length; offset += blockSizeInBytes) {\r\n        // Save this crypted block\r\n        var thisCryptedBlock = c.slice(offset, offset + blockSizeInBytes);\r\n        // Decrypt block\r\n        cipher._decryptblock(c, offset);\r\n        // XOR decrypted block using previous crypted block\r\n        for (var i = 0; i < blockSizeInBytes; i++) {\r\n            c[offset + i] ^= prevCryptedBlock[i];\r\n        }\r\n        prevCryptedBlock = thisCryptedBlock;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Cipher feed back\r\n * \r\n * The cipher output is XORed with the plain text to produce the cipher output,\r\n * which is then fed back into the cipher to produce a bit pattern to XOR the\r\n * next block with.\r\n * \r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar CFB = C_mode.CFB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CFB_prototype = CFB.prototype = new Mode;\r\n\r\n// Override padding\r\nCFB_prototype._padding = C_pad.NoPadding;\r\n\r\n// Concrete steps for Mode template\r\nCFB_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < m.length; i++) {\r\n\r\n        var j = i % blockSizeInBytes;\r\n        if (j == 0) cipher._encryptblock(keystream, 0);\r\n\r\n        m[i] ^= keystream[j];\r\n        keystream[j] = m[i];\r\n    }\r\n};\r\nCFB_prototype._doDecrypt = function (cipher, c, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < c.length; i++) {\r\n\r\n        var j = i % blockSizeInBytes;\r\n        if (j == 0) cipher._encryptblock(keystream, 0);\r\n\r\n        var b = c[i];\r\n        c[i] ^= keystream[j];\r\n        keystream[j] = b;\r\n    }\r\n};\r\n\r\n\r\n/**\r\n * Output feed back\r\n * \r\n * The cipher repeatedly encrypts its own output. The output is XORed with the\r\n * plain text to produce the cipher text.\r\n * \r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar OFB = C_mode.OFB = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar OFB_prototype = OFB.prototype = new Mode;\r\n\r\n// Override padding\r\nOFB_prototype._padding = C_pad.NoPadding;\r\n\r\n// Concrete steps for Mode template\r\nOFB_prototype._doEncrypt = function (cipher, m, iv) {\r\n\r\n    var blockSizeInBytes = cipher._blocksize * 4,\r\n        keystream = iv.slice(0);\r\n\r\n    // Encrypt each byte\r\n    for (var i = 0; i < m.length; i++) {\r\n\r\n        // Generate keystream\r\n        if (i % blockSizeInBytes == 0)\r\n            cipher._encryptblock(keystream, 0);\r\n\r\n        // Encrypt byte\r\n        m[i] ^= keystream[i % blockSizeInBytes];\r\n\r\n    }\r\n};\r\nOFB_prototype._doDecrypt = OFB_prototype._doEncrypt;\r\n\r\n/**\r\n * Counter\r\n * @author Gergely Risko\r\n *\r\n * After every block the last 4 bytes of the IV is increased by one\r\n * with carry and that IV is used for the next block.\r\n *\r\n * This is a stream cipher mode and does not require padding.\r\n */\r\nvar CTR = C_mode.CTR = function () {\r\n    // Call parent constructor\r\n    Mode.apply(this, arguments);\r\n};\r\n\r\n// Inherit from Mode\r\nvar CTR_prototype = CTR.prototype = new Mode;\r\n\r\n// Override padding\r\nCTR_prototype._padding = C_pad.NoPadding;\r\n\r\nCTR_prototype._doEncrypt = function (cipher, m, iv) {\r\n    var blockSizeInBytes = cipher._blocksize * 4;\r\n    var counter = iv.slice(0);\r\n\r\n    for (var i = 0; i < m.length;) {\r\n        // do not lose iv\r\n        var keystream = counter.slice(0);\r\n\r\n        // Generate keystream for next block\r\n        cipher._encryptblock(keystream, 0);\r\n\r\n        // XOR keystream with block\r\n        for (var j = 0; i < m.length && j < blockSizeInBytes; j++, i++) {\r\n            m[i] ^= keystream[j];\r\n        }\r\n\r\n        // Increase counter\r\n        if(++(counter[blockSizeInBytes-1]) == 256) {\r\n            counter[blockSizeInBytes-1] = 0;\r\n            if(++(counter[blockSizeInBytes-2]) == 256) {\r\n                counter[blockSizeInBytes-2] = 0;\r\n                if(++(counter[blockSizeInBytes-3]) == 256) {\r\n                    counter[blockSizeInBytes-3] = 0;\r\n                    ++(counter[blockSizeInBytes-4]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\nCTR_prototype._doDecrypt = CTR_prototype._doEncrypt;\r\n\r\n})();\r\n"]}